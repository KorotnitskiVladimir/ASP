@{
    ViewData["Title"] = "IoC";
}

<div class="text-center">
    <h1 class="display-4">Inversion of Control</h1>
</div>
<p>
    <b>IoC</b> - Inversion of Control - Инверсия управления жизненным циклом объектов. 
    Паттерн проектирования, в соответствие с которым задачи создания, использования и удаления объектов перекладываются
    на специализированный модуль (Инжектор, контейнер сервисов).
    Вместо инструкций <code>new Service()</code> в каждом контроллере, который требует объект Service, данный объект 
    регистрируется один раз, а потребители (контроллеры) обращаются к этому объекту с помощью инжекции. Можно сравнить 
    идею с глобальными объектами. 
</p>
<p>
    Согласно подходу инверсии управления если у нас есть клиент, который использует некий сервис, то он должен делать 
    это не напрямую, а через посредника, своего рода аутсорсинг. То как технически это будет сделано и определяет
    каждая из реализаций подхода IoC.
</p>
<p>
    <b>IoC-контейнеры</b> помогают уменьшить количество рутины, позволяя задать соответствие между интерфейсом и его
    конкретной реализацией, чтобы потом везде этим пользоваться.
</p>
<p>
    <b>Не путать:</b><br/>
    <b>IoC</b> - Inversion of Control - паттерн<br/>
    <b>DIP</b> - Dependency Inversion Principle (SOLID) - принцип<br/>
    <b>DI</b> - Dependency Injection - способ передачи ссылок на сервисы
</p>
<p>
    IoC внедрен в ASP "с коробки". 
    Процесс использования можно описать следующими шагами:
</p>
<ol>
    <li>(Единоразово) - создаем директорию "Services"</li>
    <li>Определяемся с сервисом, который понадобится в разных "местах. Например, это сервис времени, который
        возвращает timestamp</li>
    <li>Создаем директорию для данной службы (например, Timestamp) в общей директории "Services"</li>
    <li>Создаем интерфейс ITimestampService (в директории Timestamp, создаем класс-имплементацию интерфейса
        SystemTimestampService (в той же директории)</li>
    <li>Регистрируем сервис в Program.cs</li>
    <li>Инжектриуем сервис в нужно месте (см. HomeController), выводим на представлении: @ViewData["timestamp"] / 
        @ViewData["timestampCode"]</li>
    <li>При необходимости изменить способ работы сервиса пользуемся принципом OCP (SOLID) - не меняем, а дополняем -
        создаем новый класс UnixTimestampService (в дериктории Timestamp. Меняем регистрацию в Program.cs</li>
</ol>